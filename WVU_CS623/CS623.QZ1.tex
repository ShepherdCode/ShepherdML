\documentclass{article}
\usepackage{amsmath}
\usepackage{array}
\usepackage{tabularx}
\usepackage{multicol}
\title{WVU CS623 Quiz1}
\date{2020-01-28}
\author{Jason Miller}
\begin{document}
\maketitle
\pagenumbering{arabic}
\begin{multicols}{2}
\section{Problem Statement}
Perform big-O complexity analysis (time and space) for the following problem:
build a histogram of letter counts given an arbitrary string from an arbitrary alphabet.
The analysis will consider only the counting process itself
i.e. ignoring the space required to store the inputs and the time required to report the results.

For notation, assume the following.
\begin{align*} 
    &\sigma_{i} \in \Sigma \\
    &z = | \Sigma | \\
    &S = \sigma^n  \\
    &N = max(n) \forall S
\end{align*} 

Thus, S is a string of length n composed of letters from $\Sigma$ which is the observed alphabet of size z. 
The observed alphabet is inferred from the string, so z is bounded by n.
In each section below, we will consider one of three types of alphabet: general, ordered, indexed.

For each alphabet type, we will consider two cases. 
For the case of bounded n, the algorithm may count with fixed-size integers using int64 encoding, for example.
The space and time to maintain and update each counter is constant.
For the unbounded case, the algorithm must allow for integers of any size using BCD encoding, for example.
The space and time to maintain and update each counter grows with $O(\log{}n)$.
\section{General Alphabet}
The general alphabet is neither ordered nor indexed. 
Assume only that we can recognize whether a given letter is the same as some previously-seen letter. 
In other words, assume
\begin{equation*}
    \forall a,b  \in \Sigma : a = b 
\end{equation*}
is decidable in constant time.
\subsection{Algorithm (naive)}
Create A, an empty array of tuples \{letter,count\}.
On inspection of each successive letter x of S, compare x to every letter stored in A.
If x is found in A, short circuit the comparisons and increment the count of x in A.
Otherwise, append the new tuple \{x,1\} to the array.
After processing every x in S, each element of A will contain a tuple \{x,count(x)\}
and each x will be represented exactly once. 
\subsection{Complexity Analysis}
For each letter x in S, the algorithm loops through the previously seen letters stored in A until found or not found.
Thus, for each x, the number of comparisons is 1 best case, z worst case, and z/2 on average.
After each round of comparisons for one x, the algorithm either increments a counter or adds an array element; 
either operation requires constant time.
The number of x in S is n. 
Thus, the total number of comparisons is n best case, n*z worst case, and n*z/2 on average.
The time complexity is thus $O(n*z)$.

The space requirement for A is z times the (constant) size of one tuple.
The space complexity is thus $O(z)$.

The case of unbounded n requires log(n) extra time and space to increment and store the counts, respectively.
For the unbounded case, the time complexity is $O((n*z)\log{}n)$ and the space complexity is $O(z\log{}n)$.
\section{Ordered Alphabet}
In the ordered alphabet, there is a natural order for its letters.
Thus we assume
\begin{equation*}
    \forall a,b  \in \Sigma : a < b 
\end{equation*}
is decidable in constant time. 
Note that equality is also decidable in constant time, since (a equals b) can be redefined as (not a $<$ b and not b $<$ a).
\subsection{Algorithm (naive)}
Create A, an empty AVL tree.
As the payload in each node of A, store the tuple \{letter,count\}.
The AVL tree shall remain balanced and sorted by the natural order of the letters it contains.
On inspection of each successive letter x of S, find x in A using binary search.
If x is found in A, increment the count in the element of A that corresponds to x.
Otherwise, insert the new tuple \{x,1\} into the tree (and rebalance the tree if necessary).
\subsection{Complexity Analysis}
For each letter x in S, the algorithm performs one binary search, which requires $O(\log{}n)$ time, worst case.
After each search for x, the algorithm either increments a count or adds a node.
Node insertion requires log(n) amortized time.
The number of searches is n.
The number of insertions is z.
Thus, the algorithm must perform n*log(n) comparisons and log(z) insertions.
The time complexity is thus $O(n\log{}n+\log{}z) \cong O(n\log{}n)$.

The space requirement for A is z times the (constant) size of tree node.
The space complexity is thus $O(z)$.

The case of unbounded n requires log(n) extra time and space to increment and store the counts, respectively.
In this case, the time complexity is $O(n\log^2{}n)$ and the space complexity is $O(z\log{}n)$.
\section{Indexed Alphabet}
In the indexed alphabet, every letter has a corresponding distinct integer value between 1 and z.
Thus, assume there is a constant-time function h(x) that provides a one-to-one mapping from x to the integers 1 to z.  
\subsection{Algorithm (naive)}
Create A, an array of z elements, each initialized to zero.
Element A[i] shall hold a count associated with the letter x whose h(x) equals i.
On inspection of each successive letter x of S, increment A[h(x)].
\subsection{Complexity Analysis}
There is a one-time $O(z)$ cost to construct the array.
For each letter x in S, the algorithm performs one constant-time operation. 
With n letters in S, the algorithm performs n operations.
The time complexity is thus $O(n+z) \cong O(n)$.

The space requirement for A is z times the (constant) size of one counter.
The space complexity is thus $O(z)$.

The case of unbounded n requires log(n) extra time and space to increment and store the counts, respectively.
In this case, the time complexity is $O(n\log{}n)$ and the space complexity is $O(z\log{}n)$.
\section{Conclusion}
Below, we tabulate the space and time complexity for all cases with bounded integers.
For cases with unbounded integers, the complexity increases by log(n).
\begin{center}
\begin{tabularx}{\textwidth}{ | c | c | c | } 
 Alphabet  & Time  & Space  \\
 General  & $O(n*z)$   & $O(z)$  \\
 Ordered  & $O(n\log{}n)$ & $O(z)$  \\
 Indexed  & $O(n)$  & $O(z)$  
\end{tabularx}
\end{center}

\end{multicols}
\end{document}

